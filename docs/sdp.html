---

title: Semidefinite programming 


keywords: fastai
sidebar: home_sidebar

summary: "Toolkit to solve the semi-definite program defined by the optimization problem and its set of constraints."
description: "Toolkit to solve the semi-definite program defined by the optimization problem and its set of constraints."
nb_path: "nbs/06_sdp.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/06_sdp.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="picos2np" class="doc_header"><code>picos2np</code><a href="https://github.com/BorjaRequena/bounce/tree/master/bounce/sdp.py#L14" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>picos2np</code>(<strong><code>variable</code></strong>)</p>
</blockquote>
<p>Converts picos variable (even sparse) to numpy matrix.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="SdP-formalism">SdP formalism<a class="anchor-link" href="#SdP-formalism"> </a></h2><p>In order to formulate and solve the SdP there are two main needed items:</p>
<ul>
<li>an object containing the problem details in terms of <code>picos.Constant</code> with a <code>to_sdp()</code> method, such as a <a href="/bounce/hamiltonian.html#Hamiltonian"><code>Hamiltonian</code></a> with <a href="/bounce/hamiltonian.html#Hamiltonian.to_sdp("><code>Hamiltonian.to_sdp()</code></a>).</li>
<li>a layout based in <code>np.ndarray</code>s, e.g., <code>L = [np.array([0, 1]), np.array([0, 1, 2])</code> determining the problem constraints.</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SdPSolver" class="doc_header"><code>class</code> <code>SdPSolver</code><a href="https://github.com/BorjaRequena/bounce/tree/master/bounce/sdp.py#L19" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SdPSolver</code>(<strong><code>solver</code></strong>=<em><code>'cvxopt'</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The <a href="/bounce/sdp.html#SdPSolver"><code>SdPSolver</code></a> must be tailored to the problem instances that we aim to solve. Defining the problem and the solver should go hand-to-hand and they are handled by the <a href="/bounce/environment.html#SdPEnvironment"><code>SdPEnvironment</code></a> during the optimization. Essentially, the environment takes the result of <code>problem.to_sdp()</code> and feeds it into the solver.</p>
<p><a href="/bounce/sdp.html#SdPSolver"><code>SdPSolver</code></a>s have two main methods: <code>solve</code> and <code>ojimetro</code>. The first one, solves a problem instance given a layout, such as <code>solver.solve(problem.to_sdp(), layout)</code>. The second one estimates the cost associated to solving the SdP given a layout, with the syntax <code>solver.ojimetro(layout)</code>. We can choose any metric for the cost, for example, the amount of free variables in the resulting SdP.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Ground-state-energy-approximation">Ground state energy approximation<a class="anchor-link" href="#Ground-state-energy-approximation"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SdPEnergySolver" class="doc_header"><code>class</code> <code>SdPEnergySolver</code><a href="https://github.com/BorjaRequena/bounce/tree/master/bounce/sdp.py#L32" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SdPEnergySolver</code>(<strong><code>solver</code></strong>=<em><code>'cvxopt'</code></em>) :: <a href="/bounce/sdp.html#SdPSolver"><code>SdPSolver</code></a></p>
</blockquote>
<p>Solver to compute lower bounds of the ground state energy of local Hamiltonians. It
follows the method described in [1] (see refs below) to formulate the objective and
enforce the problem constraints.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The <a href="/bounce/sdp.html#SdPEnergySolver"><code>SdPEnergySolver</code></a> solves the problem of finding lower bounds to the ground state energy of local Hamiltonians. Hence, the <a href="/bounce/environment.html#SdPEnvironment"><code>SdPEnvironment</code></a> should receive a <a href="/bounce/hamiltonian.html#Hamiltonian"><code>Hamiltonian</code></a> as problem instance together with this solver. We use this case to illustrate the general behaviour of the <code>SdPSolvers</code> and how to use them.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">chain</span> <span class="o">=</span> <span class="n">Chain1D</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">B</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="k">3</span> for i in range(N)]
<span class="n">H</span> <span class="o">=</span> <span class="n">XXHamiltonian</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Solving-a-problem-instance">Solving a problem instance<a class="anchor-link" href="#Solving-a-problem-instance"> </a></h3><p>Now that we have defined a problem, we use the <code>solve</code> method to define the objective function, which corresponds to the expected energy, and the problem constraints, given by a layout.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="SdPEnergySolver.solve" class="doc_header"><code>SdPEnergySolver.solve</code><a href="https://github.com/BorjaRequena/bounce/tree/master/bounce/sdp.py#L37" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>SdPEnergySolver.solve</code>(<strong><code>interactions</code></strong>, <strong><code>layout</code></strong>)</p>
</blockquote>
<p>Creates and solves the SdP associated to the given layout and Hamiltonian interactions.
The result is a lower bound of the Hamiltonian's ground state energy.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The method takes the <a href="/bounce/hamiltonian.html#Hamiltonian.interactions"><code>Hamiltonian.interactions</code></a>, provided by the <a href="/bounce/hamiltonian.html#Hamiltonian.to_sdp("><code>Hamiltonian.to_sdp()</code></a>) method, and a layout with which we define the set of compatibility constraints imposed in the SdP, as we explain in <a href="https://arxiv.org/abs/2103.03830">[1]</a>.</p>
<p>Given the Hamiltonian, let's define a layout in order to compute an energy bound.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">simple_layout</span> <span class="o">=</span> <span class="n">fill_layout</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">])],</span> <span class="n">N</span><span class="p">)</span>
<span class="n">simple_layout</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[array([0, 5]), array([1]), array([2]), array([3]), array([4])]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And now we can solve the associated SdP to the Hamiltonian with the given set of constraints.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solver</span> <span class="o">=</span> <span class="n">SdPEnergySolver</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">to_sdp</span><span class="p">(),</span> <span class="n">simple_layout</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>-15.999999999012134</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Tightening the constraints, we can obtain a better energy bound. For instance, adding a 3-body element to the previous set we will obtain a higher energy.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">stronger_layout</span> <span class="o">=</span> <span class="n">fill_layout</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">])],</span> <span class="n">N</span><span class="p">)</span>
<span class="n">stronger_layout</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[array([1, 2, 3]), array([0, 5]), array([4])]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">to_sdp</span><span class="p">(),</span> <span class="n">stronger_layout</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>-12.472135949820899</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Cost-estimation">Cost estimation<a class="anchor-link" href="#Cost-estimation"> </a></h3><p>A key element of any optimization problem is its computational cost. We can take any consistent measure of the problem's cost as a valid estimation for the posterior optimization with the reinforcement learning framework. For example, since the actual complexity of solving an SdP depends on the algorithm that we use, we take the number of free parameters as a metric for the associated cost.</p>
<p>In order to get a cost estimation, we rely on the <code>ojimetro</code> method.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="SdPEnergySolver.ojimetro" class="doc_header"><code>SdPEnergySolver.ojimetro</code><a href="https://github.com/BorjaRequena/bounce/tree/master/bounce/sdp.py#L59" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>SdPEnergySolver.ojimetro</code>(<strong><code>layout</code></strong>)</p>
</blockquote>
<p>Estimates the amount of free parameters involved in the SdP associated to the <code>layout</code>.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Following our example, the first SdP was a wild relaxation of the original problem.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solver</span><span class="o">.</span><span class="n">ojimetro</span><span class="p">(</span><span class="n">simple_layout</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>31</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>However, the second one was a tighter one.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solver</span><span class="o">.</span><span class="n">ojimetro</span><span class="p">(</span><span class="n">stronger_layout</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>83</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With the first set of constraints, the resulting SdP had 31 free variables to optimize, while the second SdP had to deal with 83. Tighter energy bounds usually come at the cost of higher computational costs.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Alternative-methods-to-lower-bound-the-ground-state-energy">Alternative methods to lower bound the ground state energy<a class="anchor-link" href="#Alternative-methods-to-lower-bound-the-ground-state-energy"> </a></h3><p>We implement two other methods to obtain lower bounds of many-body Hamiltonians. We rewrite the Anderson bound <a href="https://journals.aps.org/pr/abstract/10.1103/PhysRev.83.1260">[2]</a> and the method introduced by Uskov and Lichovskiy in <a href="https://iopscience.iop.org/article/10.1088/1742-6596/1163/1/012057">[3]</a> in SdP form to compare with the proposed methodology above. The SdP formulation ensures that the obtained result is the actual global minimum.</p>
<p>The main limitation of these methods is not taking into account compatibility constraints between the reduced density matrices spanning the system. Furthermore, they rely on symmetries (such as translational invariance) and can, thus, not be used to solve inhomogeneous systems. Conversely, the approach we introduced above can be nautrally complemented by introducing additional constratints stemming from any previously known symmetry from the system.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SdPEnergyAndersonSolver" class="doc_header"><code>class</code> <code>SdPEnergyAndersonSolver</code><a href="https://github.com/BorjaRequena/bounce/tree/master/bounce/sdp.py#L109" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SdPEnergyAndersonSolver</code>(<strong><code>solver</code></strong>=<em><code>'cvxopt'</code></em>) :: <a href="/bounce/sdp.html#SdPEnergySolver"><code>SdPEnergySolver</code></a></p>
</blockquote>
<p>Solver to compute bounds to the ground state energy of local Hamiltonians implementing the
methods described in [2] (see references below). Finds the so-called Anderson bound. Assumes
the system is one-dimensional.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SdPEnergyUskovLichkovskiySolver" class="doc_header"><code>class</code> <code>SdPEnergyUskovLichkovskiySolver</code><a href="https://github.com/BorjaRequena/bounce/tree/master/bounce/sdp.py#L169" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SdPEnergyUskovLichkovskiySolver</code>(<strong><code>solver</code></strong>=<em><code>'cvxopt'</code></em>) :: <a href="/bounce/sdp.html#SdPEnergyAndersonSolver"><code>SdPEnergyAndersonSolver</code></a></p>
</blockquote>
<p>Solver to compute ground state energy bounds of local Hamiltonians. It follows the method
introduced in [3] (see references below) to improve over the Anderson bound. The method assumes
the reduced states have certain symmetries, such as translational invariance.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can quickly reproduce the results from <a href="https://iopscience.iop.org/article/10.1088/1742-6596/1163/1/012057">[3]</a> (see Table 2) by properly adjusting the cluster size and using the same Hamiltonian.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">chain</span> <span class="o">=</span> <span class="n">Chain1D</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">B</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">XYZHamiltonian</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solver_anderson</span> <span class="o">=</span> <span class="n">SdPEnergyAndersonSolver</span><span class="p">()</span>
<span class="n">solver_uskov</span> <span class="o">=</span> <span class="n">SdPEnergyUskovLichkovskiySolver</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">cluster_size</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">layout</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">cluster_size</span><span class="p">)</span><span class="o">%</span><span class="k">N</span>) for i in np.arange(0, N, cluster_size-3)]
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solver_anderson</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">to_sdp</span><span class="p">(),</span> <span class="n">cluster_size</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">,</span> <span class="n">solver_uskov</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">to_sdp</span><span class="p">(),</span> <span class="n">cluster_size</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">,</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">to_sdp</span><span class="p">(),</span> <span class="n">layout</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(-1.9278862525095595, -1.8685170845449277, -1.868517086761974)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Entanglement-witnessing">Entanglement witnessing<a class="anchor-link" href="#Entanglement-witnessing"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SdPWitnessSolver" class="doc_header"><code>class</code> <code>SdPWitnessSolver</code><a href="https://github.com/BorjaRequena/bounce/tree/master/bounce/sdp.py#L227" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SdPWitnessSolver</code>(<strong><code>solver</code></strong>=<em><code>'cvxopt'</code></em>) :: <a href="/bounce/sdp.html#SdPEnergySolver"><code>SdPEnergySolver</code></a></p>
</blockquote>
<p>Solver to detect entanglement from energy bounds. It follows the formalism described in [1]
to obtain a lower bound of the minimum energy for separable states. If we can find a state with
a lower energy than that, the state is entangled.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We take an energy-based approach to build entanglement witnesses here. The main principle is, given a Hamiltonian, we compute the minimum possible energy obtainable within the set of separable states. Then, if we find a state that yields a lower energy, it means that it is entangled <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.71.010301">[4]</a>.</p>
<p>Formally, $$\Delta E = \langle H\rangle - E_{\text{sep}}$$ denotes the energy gap between the expected energy of a state, $\langle H\rangle = \text{Tr}\left[\rho H\right]$, and the minimum energy obtainable by separable states, $E_{\text{sep}}$. If $\Delta E &lt; 0$, $\rho$ is an entangled state, as it is beyond the set of separable states. The larger the difference, $|\Delta E|$, the more robust the entanglement. Actually, $|\Delta E|$ quantifies the energy the system must receive to become separable.</p>
<p>The <a href="/bounce/sdp.html#SdPWitnessSolver"><code>SdPWitnessSolver</code></a> provides a lower bound for $E_{\text{sep}}$ given a <a href="/bounce/hamiltonian.html#Hamiltonian"><code>Hamiltonian</code></a>. We build upon the <a href="/bounce/sdp.html#SdPEnergySolver"><code>SdPEnergySolver</code></a> imposing additional constraints to enforce separability on our states. However, imposing such conditions to their full extent is extremely costly. Instead, we impose that our states are positive under partial transposition (PPT), which is a relaxation that is exact in the one-dimensional limit. Hence, the bound on $E_{\text{sep}}$.</p>
<p>Let's see an example! First of all, we need to build our problem.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">chain</span> <span class="o">=</span> <span class="n">Chain1D</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">B</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">XXHamiltonian</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we can instantiate our solver.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solver_witness</span> <span class="o">=</span> <span class="n">SdPWitnessSolver</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We define a layout of 2-body terms.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">layout</span> <span class="o">=</span> <span class="n">fill_layout</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="k">N</span>]) for i in range(N)], N)
<span class="n">layout</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[array([0, 1]),
 array([1, 2]),
 array([2, 3]),
 array([3, 4]),
 array([4, 5]),
 array([0, 5])]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And now we're ready to solve it.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solver_witness</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">to_sdp</span><span class="p">(),</span> <span class="n">layout</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>-12.749999991956518</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.71.010301">[4]</a> we find analytic expressions of $E_{\text{sep}}$ for some Hamiltonians, including the XX model we consider here.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">exact_XX_sep_bound</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">/</span><span class="n">J</span><span class="o">/</span><span class="n">d</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">d</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">J</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">d</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">J</span><span class="o">*</span><span class="n">b</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">exact_XX_sep_bound</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>-12.75</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We see that, since we've chosen to implement the Hamiltonian in a one-dimensional chain, the result we obtained is exact. Now we can use the <a href="/bounce/sdp.html#SdPEnergySolver"><code>SdPEnergySolver</code></a> to obtain the ground state energy and compare it to the separable threshold.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solver_energy</span> <span class="o">=</span> <span class="n">SdPEnergySolver</span><span class="p">()</span>
<span class="n">solver_energy</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">to_sdp</span><span class="p">(),</span> <span class="n">layout</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>-23.99999993375356</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The ground state is entangled! :)</p>
<p>If we now change the Hamiltonian parameters, we can land on a separable ground state.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">B</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">XXHamiltonian</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solver_witness</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">to_sdp</span><span class="p">(),</span> <span class="n">layout</span><span class="p">),</span> <span class="n">solver_energy</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">to_sdp</span><span class="p">(),</span> <span class="n">layout</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(-29.9999999937129, -29.999999800727085)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In this case, both energies match. This confirms that the ground state is, indeed, a separable state.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="References">References<a class="anchor-link" href="#References"> </a></h1><p>[1] B. Requena, G. Muñoz-Gil, M. Lewenstein, V. Dunjko, J. Tura. <a href="https://arxiv.org/abs/2103.03830">Certificates of quantum many-body properties assisted by machine learning</a>. <em>arXiv:2103.03830 (2021)</em></p>
<p>[2] P. W. Anderson. <a href="https://journals.aps.org/pr/abstract/10.1103/PhysRev.83.1260">Limits on the Energy of the Antiferromagnetic Ground State</a>. <em>Physical Review</em> <strong>83</strong>, 1260 (1951)</p>
<p>[3] F. Uskov and O. Lychkovskiy. <a href="https://iopscience.iop.org/article/10.1088/1742-6596/1163/1/012057">A variational lower bound on the ground state of a many-body system and the squaring parametrization of density matrices</a>. <em>Journal of Physics: Conference Series</em> <strong>1163</strong> 012057 (2019)</p>
<p>[4] G. Tóth. <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.71.010301">Entanglement Witnesses in Spin Models</a>. <em>Physical Review A</em> <strong>71</strong> 010301 (2005).</p>

</div>
</div>
</div>
</div>
 

