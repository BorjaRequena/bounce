# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/source/02_hamiltonian.ipynb.

# %% auto 0
__all__ = ['Graph', 'Chain1D', 'SquareLattice', 'Hamiltonian', 'LocalHamiltonian', 'IsingHamiltonian', 'XYHamiltonian',
           'XXHamiltonian', 'XYZHamiltonian']

# %% ../nbs/source/02_hamiltonian.ipynb 1
import re
import picos
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from copy import copy, deepcopy
from collections.abc import Iterable

from bounce.utils import arrayfy, array_in_list

# %% ../nbs/source/02_hamiltonian.ipynb 5
class Graph:
    def __init__(self, nodes, edges):
        self.nodes, self.edges = nodes, edges
        
    @property
    def n_nodes(self): return len(self.nodes)
    
    @property
    def n_edges(self): return len(self.edges)

# %% ../nbs/source/02_hamiltonian.ipynb 12
class Chain1D(Graph):
    def __init__(self, N, pbc=True):
        "Create a one-dimensional chain of `N` nodes and periodic boundary conditions `pbc`."
        nodes = np.arange(N)
        edges = [np.sort([i, (i+1)%N]) for i in range(N if pbc else N-1)]
        super().__init__(nodes, edges)
        self.layout = nx.circular_layout

# %% ../nbs/source/02_hamiltonian.ipynb 15
class SquareLattice(Graph):
    def __init__(self, N, M, pbc=True):
        "Create a NxM square lattice with periodic boundary conditions `pbc`."
        self.n_rows, self.n_cols, self.pbc = N, M, pbc
        nodes = np.arange(N*M)
        edges = []
        for i in range(N):
            for j in range(M):
                n = i*M + j
                # Horizontal edges
                if pbc or j != M-1: 
                    n_h = i*M + (j+1)%M
                    edge = np.sort([n, n_h])
                    if not array_in_list(edge, edges): edges.append(edge)
                # Vertical edges
                if pbc or i != N-1:
                    n_v = ((i+1)%N)*M + j
                    edge = np.sort([n, n_v])
                    if not array_in_list(edge, edges): edges.append(edge)           
        super().__init__(nodes, edges)
    
    def layout(self, G):
        "Returns plot positions for a `networkx.Graph` depicting the lattice."
        pos_x = np.linspace(-1, 1, self.n_cols)
        pos_y = np.linspace(1, -1, self.n_rows)
        if self.pbc:
            dy, dx = 1/self.n_rows, 1/self.n_cols
            pos = {}
            for n in G.nodes:
                row, col = n//self.n_cols, n%self.n_cols
                x, y = pos_x[col], pos_y[row]
                left, right = col == 0, col == self.n_cols - 1
                top, bottom = row == 0, row == self.n_rows - 1 
                if not left and not right: y -= dy
                if not top and not bottom:
                    if right: x += dx
                    else:     x -= dx
                pos[n] = np.array([x, y])
            return pos
        else: 
            return {n: np.array([pos_x[n%self.n_cols], pos_y[n//self.n_cols]]) for n in G.nodes}

# %% ../nbs/source/02_hamiltonian.ipynb 19
class Hamiltonian:
    
    x = picos.Constant('x', [[0, 1], [1, 0]])
    y = picos.Constant('y', [[0, -1j], [1j, 0]])
    z = picos.Constant('z', [[1, 0], [0, -1]])
    Id = picos.Constant('Id', [[1, 0], [0, 1]])
    
    def __init__(self, graph, interactions):
        "Create a Hamiltonian over a graph with defined interactions."
        self.graph, self.interactions = graph, interactions
        self.name = 'base'
        
    def to_sdp(self):
        "Outputs the necessary information for the `SdPSolver`."
        return self.interactions
    
    def draw(self, figsize=(8,6), cmap=plt.cm.viridis):
        "Conceptual drawing of the system."
        G = nx.Graph()            
        G.add_nodes_from([(node.item(), {'w': self._get_weight(w)}) 
                          for node, w in self.interactions if len(node) == 1])
        G.add_edges_from([(*edge.tolist(), {'w': self._get_weight(w)}) 
                          for edge, w in self.interactions if len(edge) == 2])
        
        try: 
            pos = self.graph.layout(G)
        except:
            pos = nx.kamada_kawai_layout(G)
        plt.figure()
        node_weights = [d['w'] for _, d in G.nodes(data=True)]
        edge_weights = [d['w'] for _, _, d in G.edges(data=True)]
        nx.draw_networkx_nodes(G, pos, node_color=node_weights, vmin=min(node_weights),
                               vmax=max(node_weights), cmap=cmap)
        for u, v, w in G.edges(data=True):
            nx.draw_networkx_edges(G, pos, width=4, edgelist=[(u, v)],
                                   alpha=np.abs(w['w'])/max(np.abs(edge_weights)))
        nx.draw_networkx_labels(G, pos, font_color='w');
        
    @staticmethod
    def _get_weight(expression):
        "Extracts the real or complex weight from a `picos.ComplexAffineExpression`."
        try:    
            string = re.findall('\d+\.?\d*[j]?', expression.string)[0]
            return complex(string) if string[-1] == 'j' else float(string)
        except: return 1.
        
    def __deepcopy__(self, memo):
        """Workaround to deepcopy Hamiltonians as there is an issue deepcopying `picos.Constant`.
        We deepcopy everything and only shallow copy the `Hamiltonian.interactions`. This does not
        afect our pipeline, as we not modify any parameters, we'd rather make a new `Hamiltonian`,
        but we do need to deepcopy environments containing Hamiltonians."""
        cls = self.__class__
        new = cls.__new__(cls)
        for k, v in self.__dict__.items():
            setattr(new, k, deepcopy(v) if k != 'interactions' else copy(v))
        return new

# %% ../nbs/source/02_hamiltonian.ipynb 21
class LocalHamiltonian(Hamiltonian):
    def __init__(self, graph, interactions, *aux_args):
        """Local Hamiltonian with two-body interactions. This class defines a structure for 2-local
        Hamiltonians of the form cls(graph, one_body_amplitudes, two_body_amplitudes, *aux_args).
        This allows us to serialize Hamiltonians with the __reduce__ method, which we do not want
        to explicitly define for every new Hamiltonian. Let us know if you find any better
        solution to this."""
        super().__init__(graph, interactions)
        self.aux_args = aux_args
        
    def __reduce__(self):
        aux_args = self.aux_args if hasattr(self, 'aux_args') else []
        one_body = [self._get_weight(term) for edge, term in self.interactions if len(edge) == 1]
        two_body = [self._get_weight(term) for edge, term in self.interactions if len(edge) == 2]
        return (self.__class__, (self.graph, one_body, two_body, *aux_args))

# %% ../nbs/source/02_hamiltonian.ipynb 23
class IsingHamiltonian(LocalHamiltonian):
    def __init__(self, graph, field, coupling):
        field, coupling = arrayfy(field, graph.n_nodes), arrayfy(coupling, graph.n_edges)
        one_body_terms = [(np.array([n]), field[n]*self.x) for n in graph.nodes]
        two_body_terms = [(edge, coupling[e]*self.z@self.z) for e, edge in enumerate(graph.edges)]
        interactions = one_body_terms + two_body_terms
        super().__init__(graph, interactions)
        self.name = 'ising'        

# %% ../nbs/source/02_hamiltonian.ipynb 36
class XYHamiltonian(LocalHamiltonian):
    def __init__(self, graph, linear, quadratic, gamma):
        linear, quadratic = arrayfy(linear, graph.n_nodes), arrayfy(quadratic, graph.n_edges)
        one_body_terms = [(np.array([n]), linear[n]*self.z) for n in graph.nodes]
        two_body_terms = [(edge, self._2body(quadratic[e], gamma))
                          for e, edge in enumerate(graph.edges)]
        interactions = one_body_terms + two_body_terms
        super().__init__(graph, interactions, gamma)
        self.name = 'xy'
        
    def _2body(self, amplitude, gamma):
        return amplitude*((1+gamma)*self.x@self.x + (1-gamma)*self.y@self.y)

class XXHamiltonian(XYHamiltonian):
    def __init__(self, graph, linear, quadratic):
        super().__init__(graph, linear, quadratic, gamma=0.)
        self.name = 'xx'
        self.aux_args = []

# %% ../nbs/source/02_hamiltonian.ipynb 40
class XYZHamiltonian(LocalHamiltonian):
    def __init__(self, graph, linear, quadratic):
        linear, quadratic = arrayfy(linear, graph.n_nodes), arrayfy(quadratic, graph.n_edges)
        one_body_terms = [(np.array([n]), linear[n]*self.z) for n in graph.nodes]
        two_body_terms = [(edge, self._2body(quadratic[e])) for e, edge in enumerate(graph.edges)]
        interactions = one_body_terms + two_body_terms
        super().__init__(graph, interactions)
        self.name = 'xyz'
        
    def _2body(self, amplitude):
        return amplitude*(self.x@self.x + self.y@self.y + self.z@self.z)
